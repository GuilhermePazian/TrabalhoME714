D = c(0,0)
t.BpiD_ex1b <- test.Bpi.D(estimado_theta_1,B,D)
B1 <- matrix(c(0:4,0,-1,-2,-3,-4,rep(0,5)),1,15,byrow = TRUE)
D1 <- 0
t.BpiD_ex1b_SaxSo <- test.Bpi.D(estimado_theta_1,B1,D1)
B2 <- matrix(c(0:4,rep(0,5),0,-1,-2,-3,-4),1,15,byrow = TRUE)
D2 <- 0
t.BpiD_ex1b_SaxSs <- test.Bpi.D(estimado_theta_1,B2,D2)
B3 <- matrix(c(rep(0,5),0:4,0,-1,-2,-3,-4),1,15,byrow = TRUE)
D3 <- 0
t.BpiD_ex1b_SoxSs <- test.Bpi.D(estimado_theta_1,B3,D3)
#modelo 1
#ajuste do modelo 1
m.X1 <- matrix(c(1,0,0,0,1,0,0,0,1),3,3,byrow = T)
A = matrix(c(0:4,numeric(10),numeric(5),(0:4),numeric(5),numeric(10),(0:4)),3,15,byrow=T)
Resultado_1 = MR.Api.Xbeta(estimado_theta_1,A,m.X1)
# verificação do ajuste do modelo 1
f_1 = A%*%(estimado_theta_1$vpc)
sigma_f_1 = A%*%(estimado_theta_1$mcov)%*%t(A)
beta_1 = Resultado_1$vbeta
f_menos_xbeta_1 = (f_1-m.X1%*%(beta_1))
qr_1 = t(f_menos_xbeta_1)%*%ginv(sigma_f_1)%*%(f_menos_xbeta_1)
betas_1 = data.frame(Resultado_1$vbeta,Resultado_1$epbeta,Resultado_1$vbeta-1.96*Resultado_1$epbeta,Resultado_1$vbeta+1.96*Resultado_1$epbeta)
names(betas_1)=c("Estimado","DP","LIIC","LSIC")
pd <- position_dodge(0.1)
# gráfico de de estimativas para o modelo 1 e seus respectivos erros padrão
g1 = ggplot(betas_1, aes(x=c(1,2,3), y=Estimado)) + geom_point(position=pd, size=3, shape=21, fill="white")+
geom_errorbar(aes(ymin=Estimado-DP, ymax=Estimado+DP),colour="black", width=.1, position=pd)+theme_bw()
#modelo 2
#ajuste do modelo 2
m.X2 <- matrix(c(1,0,0,1,1,0),3,2,byrow = T)
A_2 <- matrix(c(rep(c(0:4,rep(0,15)),3)),3,15,byrow = T)
Resultado_2 = MR.Api.Xbeta(estimado_theta_1,A_2,m.X2)
# verificação do ajuste do modelo 2
f_2 = A_2%*%(estimado_theta_1$vpc)
sigma_f_2 = A_2%*%(estimado_theta_1$mcov)%*%t(A_2)
beta_2 = Resultado_2$vbeta
f_menos_xbeta_2 = (f_2-m.X2%*%(beta_2))
#estatística qui-quadrado para ajuste do modelo
qr_2 = t(f_menos_xbeta_2)%*%ginv(sigma_f_2)%*%(f_menos_xbeta_2)
betas_2 = data.frame(Resultado_2$vbeta,Resultado_2$epbeta,Resultado_2$vbeta-1.96*Resultado_2$epbeta,Resultado_2$vbeta+1.96*Resultado_2$epbeta)
names(betas_2)=c("Estimado","DP","LIIC","LSIC")
# gráfico de de estimativas para o modelo 2 e seus respectivos erros padrão, não tem sentido colocar no trabalho se o modelo não se ajustar bem
g2 = ggplot(betas_2, aes(x=c(1,2), y=Estimado)) + geom_point(position=pd, size=3, shape=21, fill="white")+
geom_errorbar(aes(ymin=Estimado-DP, ymax=Estimado+DP),colour="black", width=.1, position=pd)+theme_bw()
m.C = matrix(c(1,0,-1),1,3)
v.M = 0
testa.CB.M.Api.Xbeta(Resultado_1,m.C,v.M)
m.C = matrix(c(1,0,-1),1,3)
v.M = 0
testeCB <- testa.CB.M.Api.Xbeta(Resultado_1,m.C,v.M)
testeCB
# estima os parâmetros de uma única tabela
# r x s oriunda de um modelo multinomial
# ou produto de multinomiais
# LEMBRETE: A FUNÇÃO SEMPRE CONCATENA VERTICALMENTE AS LINHAS. ASSIM
# NO CASO DO MODELO PRODUTO DE MULTINOMIAIS, CADA LINHA DEVE REPRESENTAR
# UMA MULTINOMIAL
#input= tabela: tabela de contingência
#       modelo: 1 - multinomial, 2 - produto de multinomais
#       gama: nível de confiança para a construção dos IC's
estima.theta<-function(tabela,modelo,gama)
{
auxl1 <-c(rownames(tabela))
auxl2 <-c(colnames(tabela))
label<-c(paste(auxl1[1],"&",auxl2[1]))
for(i in 1:nrow(tabela))
{
for(j in 1:ncol(tabela))
{
label<-rbind(label,c(paste(auxl1[i],"&",auxl2[j])))
}
}
label<-cbind(label[2:nrow(label),])
if(modelo ==1) # multinomial
{
vn <- c(t(tabela))
n  <- sum(vn)
ncat <- length(vn)
vp <- vn/n
#vp[vp==0]=0.01
vpc <- cbind(vp)
aux <- vpc%*%t(vpc)
mcov <- matrix(as.numeric((as.matrix(Diagonal(ncat,vpc))- aux)/n),ncat,ncat)
ep <- sqrt(diag(mcov))
epc<-cbind(ep)
}
else if(modelo ==2)# produto de multinomias
{
vn <- as.numeric(apply(tabela,1,sum))
vpg<- tabela/vn#c(t(tabela/vn))
ncatr<- ncol(tabela)
nmult<-nrow(tabela)
#vpg[vpg==0]=0.01
vp <- vpg[1,]
vpc <- cbind(vp)
aux <-vpc%*%t(vpc)
mcov <- matrix((as.matrix(Diagonal(ncatr,vpc))- aux)/vn[1],ncatr,ncatr)
mcovg <-mcov
for(j in 2:nmult)
{
vp <- vpg[j,]
vpc <- cbind(vp)
aux <-vpc%*%t(vpc)
mcov <- matrix((as.matrix(Diagonal(ncatr,vpc))- aux)/vn[j],ncatr,ncatr)
mcovg<-bdiag(mcovg,mcov)
}
mcov<-as.matrix(bdiag(mcovg))
vp<- c(t(vpg))
vpc<-cbind(vp)
ep<- sqrt(diag(mcov))
epc<-cbind(ep)
}
qic <- qnorm(0.5*(1+gama))
LIIC <- c(vpc)-c(qic*epc)
LSIC <- c(vpc)+ c(qic*epc)
mIC  <- cbind(LIIC,LSIC)
mIC[mIC[,1]<=0,1]=0
mIC[mIC[,2]>=1,2]=1
m.result <-cbind(round(vpc,2),round(epc,2),round(mIC,2))
rownames(m.result)<-label
colnames(m.result)<- c("Estimativa","EP","LIIC","LSIC")
result<- list(vpc=vpc,epc=epc,mIC=mIC,mcov=mcov,label=label)
return(result)
}
# gera gráficos das porporções estimadas (sem considerar modelos)
#input= tabela: tabela de contingência
#       result: objeto com o resultado da aplicação da função estima.theta
#       oplas: orientação dos "labels" do eixo "x"
#       eixo: dimensão dos labels dos eixos
plot.graf.prop<-function(result,oplas,eixo)
{
label<-c(result$label)
vpc<-cbind(c(result$vpc))
mIC<-(result$mIC)
mIC<- cbind(c(mIC[,1]),c(mIC[,2]))
plotCI(vpc,ui=mIC[,2],li=mIC[,1],axes=F,xlab="categoria",ylab="proporções",pch=19,cex=1.2,cex.axis=1.2,cex.lab=1.2)
axis(2,cex.axis=1.2)
axis(1,1:length(vpc),labels=label,cex.axis=eixo,las=oplas)
}
# Realiza testes do tipo Bpi=D para uma única tabela
# r x s oriunda de um modelo multinomial
# ou produto de multinomiais
#input= result: objeto com o resultado da aplicação da função estima.theta
#       m.B e v.D: matriz e vetor definidores das hipóteses de interesse, respectivamente
test.Bpi.D<-function(result,m.B,v.D)
{
vpc<-cbind(c(result$vpc))
mcov<-result$mcov
mcov[mcov==0]<-0.000000000001
e.Q <-t(m.B%*%vpc-v.D)%*%solve(m.B%*%mcov%*%t(m.B))%*%(m.B%*%vpc-v.D)
ngl<-nrow(m.B)
e.pvalor<-1-pchisq(e.Q,ngl)
#cat("Estatistica Q = ",round(e.Q,2),"\n")
#cat("pvalor = ",round(e.pvalor,4),"\n")
#cat("g.l. =",ngl,"\n")
#cat("Matriz B :","\n")
#print(m.B)
#cat("Vetor D :","\n")
#print(v.D)
resultado <- list(round(e.Q,2),round(e.pvalor,4),ngl,m.B,v.D)
names(resultado) <- c("Estatistica Q","pvalor","g.l.","B","D")
return(resultado)
}
# Ajusta modelos de regressão do tipo Api=Xbeta para uma única tabela
# r x s oriunda de um modelo multinomial
# ou produto de multinomiais
#input= result: objeto com o o resultado da aplicação da função estima.theta
#       m.B e m.X: matrizes definidoras do modelo de interesse
MR.Api.Xbeta<-function(result,m.A,m.X)
{
label<-c(result$label)
vpc<-cbind(c(result$vpc))
mcov<-result$mcov
mcov[mcov==0]<-0.000000000001
mcovF <- m.A%*%mcov%*%t(m.A)
auxav <- eigen(mcovF,only.values=TRUE)$values
nlmcovF <- nrow(mcovF)
while(min(auxav) <= 0.000000001)
{
mcovF <- mcovF + diag(0.00001,nlmcovF,nlmcovF)
auxav <- eigen(mcovF,only.values=TRUE)$values
}
imcovF <- solve(mcovF)
vF <- m.A%*%vpc
mcovbeta <- solve(t(m.X)%*%imcovF%*%m.X)
vbeta<- mcovbeta%*%t(m.X)%*%imcovF%*%vF
epbeta <- cbind(c(sqrt(diag(mcovbeta))))
epl <- m.X%*%vbeta
eQ <-t(vF-epl)%*%imcovF%*%(vF-epl)
ngl<-nrow(m.X)-nrow(vbeta)
epvalor<-1-pchisq(eQ,ngl)
result<- list(vpc=vpc,vbeta=vbeta,epbeta=epbeta,mcovbeta=mcovbeta,label=label)
return(result)
}
# Testa hipóteses do tipo CB= M para modelos lineares ajustados
# via função MR.Api.Xbeta
# input = result: objeto com o resultado da aplicação da função MR.Api.Xbeta
# Matrizes m.C e v.M
testa.CB.M.Api.Xbeta<-function(result,m.C,v.M)
{
vbeta <- result$vbeta
mcovbeta <- result$mcovbeta
e.QC <- t(m.C%*%vbeta - v.M)%*%solve(m.C%*%mcovbeta%*%t(m.C))%*%(m.C%*%vbeta - v.M)
ngl<-nrow(m.C)
e.pvalor<-1-pchisq(e.QC,ngl)
return(list(e.QC,ngl,e.pvalor))
}
#Estima proporções sob o modelo Api=Xbeta
#input= result: objeto com o resultado da aplicação da função MR.Api.Xbeta
#       m.H e v.F: matriz e vetor que recuperam as proporções originais
estim.prp.ApiXbeta<-function(result,m.H,v.F,gama)
{
label<-result$label
vpc <- result$vpc
vbeta<-result$vbeta
mcovbeta<-result$mcovbeta
vpesm <- m.H%*%vbeta + v.F
mcovsm <- m.H%*%mcovbeta%*%t(m.H)
vepsm <- sqrt(diag(mcovsm))
qic <- qnorm(0.5*(1+gama))
LIIC <- c(vpesm)-c(qic*vepsm)
LSIC <- c(vpesm)+ c(qic*vepsm)
mIC  <- cbind(LIIC,LSIC)
mIC[mIC[,1]<=0,1]=0
mIC[mIC[,2]>=1,2]=1
result<- list(vpesm=vpesm,vepsm=vepsm,mcovbeta=mcovbeta,mIC=mIC)
plot(vpc,axes=F,ylim=c(min(vpc,mIC),max(vpc,mIC)),xlab="categoria",ylab="proporções",cex=1.2)
plotCI(vpesm,ui=mIC[,2],li=mIC[,1],axes=F,pch=19,cex=1.2,cex.axis=1.2,cex.lab=1.2,add=T)
axis(2,cex.axis=1.2)
axis(1,1:length(vpc),labels=label,cex.axis=1.2)
}
# Ajusta modelos de regressão do tipo AlnGpi=Xbeta para uma única tabela
# r x s oriunda de um modelo multinomial
# ou produto de multinomiais
# input= result: objeto com o o resultado da aplicação da função estima.theta
#       m.B, m.G e m.X: matrizes definidoras do modelo de interesse
MR.AlnGpi.Xbeta<-function(result,m.A,m.G,m.X)
{
label<-c(result$label)
vpc<-cbind(c(result$vpc))
mcov<-result$mcov
mcov[mcov==0]<-0.000000000001
auxmG<-m.G%*%vpc
auxmG[auxmG==0]<-0.000000000001
m.B <- solve(diag(c(auxmG)))
mPsi <- m.A%*%m.B%*%m.G
mcovF <- mPsi%*%mcov%*%t(mPsi)
auxav <- eigen(mcovF,only.values=TRUE)$values
nlmcovF <- nrow(mcovF)
while(min(auxav) <= 0.001)
{
mcovF <- mcovF + diag(0.00001,nlmcovF,nlmcovF)
auxav <- eigen(mcovF,only.values=TRUE)$values
}
imcovF <- solve(mcovF)
vF <- m.A%*%(log(auxmG))
mcovbeta <- solve(t(m.X)%*%imcovF%*%m.X)
vbeta<- mcovbeta%*%t(m.X)%*%imcovF%*%vF
epbeta <- cbind(c(sqrt(diag(mcovbeta))))
epl <- m.X%*%vbeta
eQ <-t(vF-epl)%*%imcovF%*%(vF-epl)
ngl<-nrow(m.X)-nrow(vbeta)
epvalor<-1-pchisq(eQ,ngl)
cat("Est. dos par. beta","\n")
print(round(cbind(vbeta,epbeta),2))
cat("Teste para a qualidade do ajuste do modelo = ",round(eQ,2),"\n")
cat("pvalor = ",round(epvalor,4),"\n")
cat("g.l. =",ngl,"\n")
cat("Matriz A :","\n")
print(m.A)
cat("Matriz X :","\n")
print(m.X)
result<- list(vpc=vpc,vbeta=vbeta,epbeta=epbeta,mcovbeta=mcovbeta,label=label)
return(result)
}
m.C = matrix(c(1,0,-1),1,3)
v.M = 0
testeCB <- testa.CB.M.Api.Xbeta(Resultado_1,m.C,v.M)
testeCB$
a
testeCB
# estima os parâmetros de uma única tabela
# r x s oriunda de um modelo multinomial
# ou produto de multinomiais
# LEMBRETE: A FUNÇÃO SEMPRE CONCATENA VERTICALMENTE AS LINHAS. ASSIM
# NO CASO DO MODELO PRODUTO DE MULTINOMIAIS, CADA LINHA DEVE REPRESENTAR
# UMA MULTINOMIAL
#input= tabela: tabela de contingência
#       modelo: 1 - multinomial, 2 - produto de multinomais
#       gama: nível de confiança para a construção dos IC's
estima.theta<-function(tabela,modelo,gama)
{
auxl1 <-c(rownames(tabela))
auxl2 <-c(colnames(tabela))
label<-c(paste(auxl1[1],"&",auxl2[1]))
for(i in 1:nrow(tabela))
{
for(j in 1:ncol(tabela))
{
label<-rbind(label,c(paste(auxl1[i],"&",auxl2[j])))
}
}
label<-cbind(label[2:nrow(label),])
if(modelo ==1) # multinomial
{
vn <- c(t(tabela))
n  <- sum(vn)
ncat <- length(vn)
vp <- vn/n
#vp[vp==0]=0.01
vpc <- cbind(vp)
aux <- vpc%*%t(vpc)
mcov <- matrix(as.numeric((as.matrix(Diagonal(ncat,vpc))- aux)/n),ncat,ncat)
ep <- sqrt(diag(mcov))
epc<-cbind(ep)
}
else if(modelo ==2)# produto de multinomias
{
vn <- as.numeric(apply(tabela,1,sum))
vpg<- tabela/vn#c(t(tabela/vn))
ncatr<- ncol(tabela)
nmult<-nrow(tabela)
#vpg[vpg==0]=0.01
vp <- vpg[1,]
vpc <- cbind(vp)
aux <-vpc%*%t(vpc)
mcov <- matrix((as.matrix(Diagonal(ncatr,vpc))- aux)/vn[1],ncatr,ncatr)
mcovg <-mcov
for(j in 2:nmult)
{
vp <- vpg[j,]
vpc <- cbind(vp)
aux <-vpc%*%t(vpc)
mcov <- matrix((as.matrix(Diagonal(ncatr,vpc))- aux)/vn[j],ncatr,ncatr)
mcovg<-bdiag(mcovg,mcov)
}
mcov<-as.matrix(bdiag(mcovg))
vp<- c(t(vpg))
vpc<-cbind(vp)
ep<- sqrt(diag(mcov))
epc<-cbind(ep)
}
qic <- qnorm(0.5*(1+gama))
LIIC <- c(vpc)-c(qic*epc)
LSIC <- c(vpc)+ c(qic*epc)
mIC  <- cbind(LIIC,LSIC)
mIC[mIC[,1]<=0,1]=0
mIC[mIC[,2]>=1,2]=1
m.result <-cbind(round(vpc,2),round(epc,2),round(mIC,2))
rownames(m.result)<-label
colnames(m.result)<- c("Estimativa","EP","LIIC","LSIC")
result<- list(vpc=vpc,epc=epc,mIC=mIC,mcov=mcov,label=label)
return(result)
}
# gera gráficos das porporções estimadas (sem considerar modelos)
#input= tabela: tabela de contingência
#       result: objeto com o resultado da aplicação da função estima.theta
#       oplas: orientação dos "labels" do eixo "x"
#       eixo: dimensão dos labels dos eixos
plot.graf.prop<-function(result,oplas,eixo)
{
label<-c(result$label)
vpc<-cbind(c(result$vpc))
mIC<-(result$mIC)
mIC<- cbind(c(mIC[,1]),c(mIC[,2]))
plotCI(vpc,ui=mIC[,2],li=mIC[,1],axes=F,xlab="categoria",ylab="proporções",pch=19,cex=1.2,cex.axis=1.2,cex.lab=1.2)
axis(2,cex.axis=1.2)
axis(1,1:length(vpc),labels=label,cex.axis=eixo,las=oplas)
}
# Realiza testes do tipo Bpi=D para uma única tabela
# r x s oriunda de um modelo multinomial
# ou produto de multinomiais
#input= result: objeto com o resultado da aplicação da função estima.theta
#       m.B e v.D: matriz e vetor definidores das hipóteses de interesse, respectivamente
test.Bpi.D<-function(result,m.B,v.D)
{
vpc<-cbind(c(result$vpc))
mcov<-result$mcov
mcov[mcov==0]<-0.000000000001
e.Q <-t(m.B%*%vpc-v.D)%*%solve(m.B%*%mcov%*%t(m.B))%*%(m.B%*%vpc-v.D)
ngl<-nrow(m.B)
e.pvalor<-1-pchisq(e.Q,ngl)
#cat("Estatistica Q = ",round(e.Q,2),"\n")
#cat("pvalor = ",round(e.pvalor,4),"\n")
#cat("g.l. =",ngl,"\n")
#cat("Matriz B :","\n")
#print(m.B)
#cat("Vetor D :","\n")
#print(v.D)
resultado <- list(round(e.Q,2),round(e.pvalor,4),ngl,m.B,v.D)
names(resultado) <- c("Estatistica Q","pvalor","g.l.","B","D")
return(resultado)
}
# Ajusta modelos de regressão do tipo Api=Xbeta para uma única tabela
# r x s oriunda de um modelo multinomial
# ou produto de multinomiais
#input= result: objeto com o o resultado da aplicação da função estima.theta
#       m.B e m.X: matrizes definidoras do modelo de interesse
MR.Api.Xbeta<-function(result,m.A,m.X)
{
label<-c(result$label)
vpc<-cbind(c(result$vpc))
mcov<-result$mcov
mcov[mcov==0]<-0.000000000001
mcovF <- m.A%*%mcov%*%t(m.A)
auxav <- eigen(mcovF,only.values=TRUE)$values
nlmcovF <- nrow(mcovF)
while(min(auxav) <= 0.000000001)
{
mcovF <- mcovF + diag(0.00001,nlmcovF,nlmcovF)
auxav <- eigen(mcovF,only.values=TRUE)$values
}
imcovF <- solve(mcovF)
vF <- m.A%*%vpc
mcovbeta <- solve(t(m.X)%*%imcovF%*%m.X)
vbeta<- mcovbeta%*%t(m.X)%*%imcovF%*%vF
epbeta <- cbind(c(sqrt(diag(mcovbeta))))
epl <- m.X%*%vbeta
eQ <-t(vF-epl)%*%imcovF%*%(vF-epl)
ngl<-nrow(m.X)-nrow(vbeta)
epvalor<-1-pchisq(eQ,ngl)
result<- list(vpc=vpc,vbeta=vbeta,epbeta=epbeta,mcovbeta=mcovbeta,label=label)
return(result)
}
# Testa hipóteses do tipo CB= M para modelos lineares ajustados
# via função MR.Api.Xbeta
# input = result: objeto com o resultado da aplicação da função MR.Api.Xbeta
# Matrizes m.C e v.M
testa.CB.M.Api.Xbeta<-function(result,m.C,v.M)
{
vbeta <- result$vbeta
mcovbeta <- result$mcovbeta
e.QC <- t(m.C%*%vbeta - v.M)%*%solve(m.C%*%mcovbeta%*%t(m.C))%*%(m.C%*%vbeta - v.M)
ngl<-nrow(m.C)
e.pvalor<-1-pchisq(e.QC,ngl)
resultado <- list(round(e.QC,2),round(e.pvalor,4),ngl,m.C,v.M)
names(resultado) <- c("Estatistica Q","pvalor","g.l.","C","M")
return(resultado)
}
#Estima proporções sob o modelo Api=Xbeta
#input= result: objeto com o resultado da aplicação da função MR.Api.Xbeta
#       m.H e v.F: matriz e vetor que recuperam as proporções originais
estim.prp.ApiXbeta<-function(result,m.H,v.F,gama)
{
label<-result$label
vpc <- result$vpc
vbeta<-result$vbeta
mcovbeta<-result$mcovbeta
vpesm <- m.H%*%vbeta + v.F
mcovsm <- m.H%*%mcovbeta%*%t(m.H)
vepsm <- sqrt(diag(mcovsm))
qic <- qnorm(0.5*(1+gama))
LIIC <- c(vpesm)-c(qic*vepsm)
LSIC <- c(vpesm)+ c(qic*vepsm)
mIC  <- cbind(LIIC,LSIC)
mIC[mIC[,1]<=0,1]=0
mIC[mIC[,2]>=1,2]=1
result<- list(vpesm=vpesm,vepsm=vepsm,mcovbeta=mcovbeta,mIC=mIC)
plot(vpc,axes=F,ylim=c(min(vpc,mIC),max(vpc,mIC)),xlab="categoria",ylab="proporções",cex=1.2)
plotCI(vpesm,ui=mIC[,2],li=mIC[,1],axes=F,pch=19,cex=1.2,cex.axis=1.2,cex.lab=1.2,add=T)
axis(2,cex.axis=1.2)
axis(1,1:length(vpc),labels=label,cex.axis=1.2)
}
# Ajusta modelos de regressão do tipo AlnGpi=Xbeta para uma única tabela
# r x s oriunda de um modelo multinomial
# ou produto de multinomiais
# input= result: objeto com o o resultado da aplicação da função estima.theta
#       m.B, m.G e m.X: matrizes definidoras do modelo de interesse
MR.AlnGpi.Xbeta<-function(result,m.A,m.G,m.X)
{
label<-c(result$label)
vpc<-cbind(c(result$vpc))
mcov<-result$mcov
mcov[mcov==0]<-0.000000000001
auxmG<-m.G%*%vpc
auxmG[auxmG==0]<-0.000000000001
m.B <- solve(diag(c(auxmG)))
mPsi <- m.A%*%m.B%*%m.G
mcovF <- mPsi%*%mcov%*%t(mPsi)
auxav <- eigen(mcovF,only.values=TRUE)$values
nlmcovF <- nrow(mcovF)
while(min(auxav) <= 0.001)
{
mcovF <- mcovF + diag(0.00001,nlmcovF,nlmcovF)
auxav <- eigen(mcovF,only.values=TRUE)$values
}
imcovF <- solve(mcovF)
vF <- m.A%*%(log(auxmG))
mcovbeta <- solve(t(m.X)%*%imcovF%*%m.X)
vbeta<- mcovbeta%*%t(m.X)%*%imcovF%*%vF
epbeta <- cbind(c(sqrt(diag(mcovbeta))))
epl <- m.X%*%vbeta
eQ <-t(vF-epl)%*%imcovF%*%(vF-epl)
ngl<-nrow(m.X)-nrow(vbeta)
epvalor<-1-pchisq(eQ,ngl)
cat("Est. dos par. beta","\n")
print(round(cbind(vbeta,epbeta),2))
cat("Teste para a qualidade do ajuste do modelo = ",round(eQ,2),"\n")
cat("pvalor = ",round(epvalor,4),"\n")
cat("g.l. =",ngl,"\n")
cat("Matriz A :","\n")
print(m.A)
cat("Matriz X :","\n")
print(m.X)
result<- list(vpc=vpc,vbeta=vbeta,epbeta=epbeta,mcovbeta=mcovbeta,label=label)
return(result)
}
m.C = matrix(c(1,0,-1),1,3)
v.M = 0
testeCB <- testa.CB.M.Api.Xbeta(Resultado_1,m.C,v.M)
testeCB$pvalor
